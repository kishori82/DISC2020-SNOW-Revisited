\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

\usepackage{amssymb}
\usepackage{color}
\usepackage{ifthen}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath,multicol}
\usepackage{ioa_code}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{diagbox}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{cleveref}

\input{nn_macros}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newcommand{\states}[1]{{\textit{states}(#1)}}
\newcommand{\startstates}[1]{{\textit{start}(#1)}}
\newcommand{\sig}[1]{{\textit{sig}(#1)}}
\newcommand{\inactions}[1]{{\textit{in}(#1)}}
\newcommand{\outactions}[1]{{\textit{out}(#1)}}
\newcommand{\intactions}[1]{{\textit{int}(#1)}}
\newcommand{\extactions}[1]{{\textit{ext}(#1)}}
\newcommand{\trans}[1]{{\textit{trans}(#1)}}
\newcommand{\encode}[3]{{\textit{encode}_{#1, #2}(#3)}}
\newcommand{\decode}[3]{{\textit{decode}_{#1, #2}(#3)}}
\newcommand{\writeop}[2]{{ \textit{write}( #1, #2) }}
\newcommand{\readop}[1]{{ \textit{read}(#1)}}
\newcommand{\Writetr}[1]{{\textit{W}(#1)}}
\newcommand{\Readtr}[1]{{\textit{R}(#1)}}
\newcommand{\rot}{READ transaction}
\newcommand{\roT}{READ Transaction}
\newcommand{\rots}{READ transactions}
\newcommand{\wot}{WRITE transaction}
\newcommand{\wots}{WRITE transactions}
\newcommand{\wotsSNOW}{\textbf{W}RITE transactions}

\newcommand{\INV}[1]{{\textit{INV}(#1)}}
\newcommand{\RESP}[1]{{\textit{RESP}(#1)}}

\newcommand{\inv}[1]{{\textit{inv}(#1)}}
\newcommand{\resp}[1]{{\textit{resp}(#1)}}

\newcommand{\prefix}[1]{{ P(#1)}}
\newcommand{\frag}[2]{{ F_{#1}(#2)}}

\newcommand{\frage}[3]{{ #1   \ifthenelse{    \equal{#3}{} } {  \ifthenelse{ \equal{#2}{}}{}{(#2)}   }  { \ifthenelse{ \equal{#2}{}}{}{(#2)}^{(#3)}}     }}
\newcommand{\fragt}[3]{{ #1   \ifthenelse{    \equal{#3}{} } {  \ifthenelse{ \equal{#2}{}}{}{}   } 
		{ \ifthenelse{ \equal{#2}{}}{}{}^{(#3)}}     }}
\newcommand{\fragn}[3]{{ #1   \ifthenelse{    \equal{#3}{} } {  \ifthenelse{ \equal{#2}{}}{}{}   } 
		{ \ifthenelse{ \equal{#2}{}}{}{}}     }}

\newcommand{\suffix}[1]{{ S(#1)}}
%\newcommand{\finiteprefix}[2]{{ \sigma_0, a_1,  \sigma_1, \cdots, a_{#1},  \sigma_{#1}, a_{#2}, \sigma_{#2} }}
\newcommand{\finiteprefix}[2]{{ \sigma_0, a_1, \ldots,  a_{#2}, \sigma_{#2} }}
\newcommand{\finiteprefixt}[2]{{ a_1, \ldots,  a_{#2} }}
\newcommand{\finiteprefixA}[2]{{ P_{#2}}}

\newcommand{\send}[2]{{\textit{send}(#1)_{#2}}}
\newcommand{\recv}[2]{{\textit{recv}(#1)_{#2}}}

%\newcommand{\idSet}{\textit{\mathcal I}}

\newcommand{\GetR}{{ \it{read-get}}}
\newcommand{\GetRV}{{ \it{read-value}}}
\newcommand{\CompR}{{ \it{read-complete}}}
\newcommand{\GetW}{{ \it{write-get}}}
\newcommand{\PutW} {{ \it{write-put}}}
\newcommand{\CommitW} {{ \it{write-commit}}}

\newcommand{\readd}{{read}}
\newcommand{\AckR} {{ \it{read-ack}}}
\newcommand{\GetRResp}{{ \it{read-get}}}
\newcommand{\GetRVResp}{{ \it{read-value}}}
\newcommand{\CompRResp}{{ \it{read-complete}}}
\newcommand{\GetWResp}{{ \it{write-get}}}
\newcommand{\PutWResp} {{ \it{write-put}}}
\newcommand{\BCastResp} {{ \it{broadcast}}}
\newcommand{\writeGetTag}{{\sc write-get}}

\newcommand{\readCompleteTag}{{\sc read-complete}}
\newcommand{\writeCommitTag}{{\sc write-commit}}
\newcommand{\readDisperseTag}{{\sc read-disperse}}
\newcommand{\disperseTag}{{\sc disperse}}
\newcommand{\valueTag}{{\sc value}}
\newcommand{\metadataTag}{{\sc metadata}}
\newcommand{\writeCodeElementTag}{{\sc write-code}}


\newcommand{\getTag}{{\it get-tag}}
\newcommand{\getTagArray}{{\it get-tag-array}}
\newcommand{\writeValue}{{\it write-value}}
\newcommand{\readValue}{{\it read-value}}
\newcommand{\readValuesAndTags}{{\it read-values-and-tags}}
\newcommand{\informReaders}{{\it inform-readers}}
\newcommand{\informReader}{{\it inform-reader}}
\newcommand{\informSerializer}{{\it update-coord}}
\newcommand{\updateCoord}{{\it update-coord}}
\newcommand{\commit}{{\it commit}}

\newcommand{\getTagTag}{{\sc get-tag}}
\newcommand{\getTagArrayTag}{{\sc get-tag-array}}
\newcommand{\writeValueTag}{{\sc write-value}}
\newcommand{\readValueTag}{{\sc read-value}}
\newcommand{\readValuesTag}{{\sc read-values}}
\newcommand{\informReadersTag}{{\sc inform-readers}}
\newcommand{\informSerializerTag}{{\sc update-coord}}
\newcommand{\informReaderTag}{{\sc inform-reader}}
\newcommand{\updateCoordTag}{{\sc  update-coord}}
\newcommand{\ackTag}{{\sc acknowledge}}
\newcommand{\commitTag}{{\sc commit}}
\newcommand{\commitedTag}{{\sc commited}}
\newcommand{\tentativeTag}{{\sc tentative}}

\newcommand{\getTagResp}{{\it get-tag-resp}}
\newcommand{\writeValueResp}{{\it write-value-resp}}
\newcommand{\readValueResp}{{\it read-value-resp}}
\newcommand{\informReadersResp}{{\it inform-readers-resp}}
\newcommand{\new}[1]{{\color{blue}[{#1}]}}
\newcommand{\delete}[1]{{\color{red}[{#1}]}}
%\newcounter{algorithm}
%\setcounter {Algorithm} {1} 

\definecolor{worange}{RGB}{245, 128, 37}
\newcommand{\wl}[1]{{\color{worange} #1}}
\newcommand{\true}[1]{{\color{blue} #1}}
\definecolor{hpurple}{rgb}{0.6, 0.4, 0.8}

\newtheorem{definition}{Definition}[section]
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%\bibliographystyle{plainurl}% the mandatory bibstyle
\begin{document}
\title{SNOW Revisited: Understanding When Ideal READ Transactions Are Possible}

\author{
\IEEEauthorblockN{Kishori M. Konwar}
\IEEEauthorblockA{
\textit{RLE, MIT} \\
 Cambridge, MA \\
kishori@mit.edu}
\and
\IEEEauthorblockN{Wyatt Lloyd}
\IEEEauthorblockA{ \textit{Computer Science}\\
\textit{Princeton University} \\
Princeton, NJ, USA \\
wlloyd@cs.princeton.edu}
\and
\IEEEauthorblockN{Haonan Lu}
\IEEEauthorblockA{
\textit{Computer Science}\\
\textit{Princeton University} \\
Princeton, NJ, USA \\
haonanl@cs.princeton.edu}
\and
\IEEEauthorblockN{Nancy Lynch}
\IEEEauthorblockA{
  \textit{CSAIL, MIT} \\
  Cambridge, MA, USA \\
lynch@csail.mit.edu}
}
\maketitle

\begin{abstract}
%\input{abstract-v2.tex}
\input{abstract}
\end{abstract}


\input{intro}

%\section{Model and architecture}\label{model}
%\input{system-model-arch-short-v1.tex}

\input{prelim-kmk-v1}
\input{snow-kmk-v1}
\input{summary}
\input{formal_proof}
\input{2clients2servers-v2}
\input{c2c_mwsr}


\section{Bounded Latency}
\subsection{No Prior Bounded Latency for SW}\label{sec:eiger}
\input{no_bounded_latency.tex}
\input{eiger_not_s.tex}

\vspace{-1em}
\subsection{SNW +  One Version,  MWMR setting}\label{mwmr_snow_one_version}
\input{SNW-one-version-short-v1.tex}
%
\subsection{SNW + One Round,  MWMR setting}\label{mwmr_snow_one_round}
\input{SNW-one-round-short-v1.tex}
%
\vspace{-0.8em}


%\section{Related Work}\label{related}
%\input{related.tex}
%
\vspace{-0.8em}
\section{Conclusion}
\input{conclusion-v1.tex}

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv, biblio}

\appendix
%\input{system-model-arch-v1.tex}

%\section{Impossibility of SNOW  with two clients with restricted communication }\label{two-client-app}
%\input{2-clients-no-C2C-impossible-v1.tex}

%\section{Impossibility of SNOW properties with  three clients}\label{three-client-app}
%\input{3-clients-yes-C2C-impossible-v1.tex}

%\input{appendix_snow.tex}

\input{appendix_v1.tex}

%\input{eiger_not_s.tex}

%\input{appendix_algrb.tex}

%\input{appendix_algrc.tex}





\end{document}
